# 객체지향 프로그래밍1

## 1. 객체지향언어
* 객체지향언어의 특징
    * 코드의 재사용성이 높다.
    * 코드의 관리가 용이하다.
    * 신뢰성이 높은 프로그래밍을 가능하게 한다.

## 2. 클래스와 객체

### 2.1 클래스와 객체의 정의와 용도
* 클래스: 객체를 정의해 놓은 것
* 객체: 실제로 존재하는 것. 사물 또는 개념
* 비유하면 TV 설계도가 클래스이고, TV 설계도를 바탕으로 만들어진 TV가 객체이다.

### 2.2 객체와 인스턴스
* 인스턴스: 클래스로부터 만들어진 객체
* 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖는다.
* 책상은 인스턴스다 -> 책상은 객체다, 책상은 책상 클래스의 객체이다 -> 책상은 책상 클래스의 인스턴스이다.

### 2.3 속성과 기능
* 객체는 속성과 기능의 집합이다.
* 그 속성과 기능을 객체의 멤버라고 한다.
* 속성: 멤버변수, 특성, 필드, 상태
* 기능: 메서드, 함수, 행위

### 2.4 인스턴스의 생성과 사용
```java
public static void main(String[] args) {
        Tv t;
        t = new Tv();
        t.channel = 7;
        t.channelDown();
        System.out.println("현재 채널은 " + t.channel + " 입니다.");
    }
```
* Tv t;
    * 참조변수 t를 선언
    * 메모리에 참조변수 t를 위한 공간이 마련된다.
    * 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.
* t = new Tv();
    * new에 의해 인스턴스가 메모리의 빈 공간에 생성
    * 주소 0x100에 생성되었다고 가정
    * 멤버변수는 각 자료형에 해당하는 기본값으로 초기화
    * 대입 연산자에 의해 생성된 객체의 주소값이 참조변수 t에 저장된다.
    * 이제는 참조변수 t를 통해 Tv 인스턴스에 접근할 수 있다.
    * 인스턴스를 다루기 위해선 참조변수가 반드시 필요하다.
* t.channel = 7;
    * 참조변수 t에 저장된 주소에 있는 인스턴스의 멤버변수 channel에 7을 저장한다.

> 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

```java
public static void main(String[] args) {
        Tv t1 = new Tv();
        Tv t2 = new Tv();
        System.out.println("t1의 channel 값은 " + t1.channel + "입니다.");
        System.out.println("t2의 channel 값은 " + t2.channel + "입니다.");
        t2 = t1;
        t1.channel = 7;
        System.out.println("t1의 channel 값을 7로 변경하였습니다.");
        System.out.println("t1의 channel 값은 " + t1.channel + "입니다.");
        System.out.println("t2의 channel 값은 " + t2.channel + "입니다.");
        
    }
```
* t2 = t1;
    * t1은 참조변수이므로, 인스턴스의 주소를 저장하고 있다.
    * t2에 t1의 값을 저장하면, t2도 t1과 같은 인스턴스를 참조하게 된다.
    * t2가 원래 참조하고 있던 인스턴스는 더 이상 사용할 수 없다.

> 둘 이상의 참조변수가 하나의 인스턴스를 가리키는 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 불가능하다.

### 2.5 객체 배열
* 객체 배열에는 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다.
```java
Tv[] tvArr = new Tv[3];
```
* 길이가 3인 Tv객체 배열이 생성된다.
* 각 요소는 참조변수의 기본값인 null로 초기화된다.
* 객체를 다루기 위한 참조변수들이 만들어진 것일뿐, 객체가 저장되지 않았다.

### 2.6 클래스의 또 다른 정의
* 프로그래밍적인 관점에서 클래스의 정의와 의미
1. 클래스: 데이터와 함수의 결합
    * 서로 관계가 깊은 변수와 함수들을 다룬다.
    * 자바에서 문자열을 클래스로 정의한 이유는 문자열과 문자열을 다루는 함수들을 함께 묶어서 다루기 위해서이다.
2. 클래스: 사용자정의 타입
    * 사용자정의 타입: 프로그래머가 서로 관계가 있는 변수들을 묶어서 하나의 타입으로 새로 추가하는 것
    * 자바 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다. 

## 3. 변수와 메서드

### 3.1 선언 위치에 따른 변수의 종류
* 인스턴스 변수
    * 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.
    * 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
    * 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
* 클래스 변수
    * 인스턴스 변수 앞에 static을 붙이면 된다.
    * 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유한다.
    * 인스턴스를 생성하지 않고 바로 사용할 수 있다.
    * 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지된다.

### 3.2 클래스 변수와 인스턴스 변수
* 클래스 변수를 사용할 때는 '클래스이름.클래스변수'의 형태로 하는 것이 좋다.
> 인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 다른 겂을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.

### 3.3 JVM 메모리 구조
* 응용프로그램이 실행되면 JVM은 시스템으로부터 메모리를 할당받는다.
* 이 메모리를 용도에 따라 여러 영역으로 나눌 수 있다. 그 중 메서드 영역, 힙 영역, 호출스택 영역이 있다.
* 메서드 영역
    * 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일(*.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다.
    * 클래스 변수도 이 영역에 함께 생성된다.
* 힙 영역
    * 인스턴스가 생성되는 공간이다.
    * 인스턴스변수들이 생성되는 공간이다.
* 호출스택 영역
    * 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당된다.
    * 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
    * 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    * 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    * 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    * 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

### 3.4 기본형 매개변수와 참조형 매개변수
* 기본형 매개변수: 변수의 값을 읽기만 할 수 있다.
* 참조형 매개변수: 변수의 값을 읽고 변경할 수 있다.

### 3.5 클래스 메서드(static 메서드)와 인스턴스 메서드
* 변수와 마찬가지로 클래스 메서드는 객체를 생성하지 않고도 호출할 수 있다.
1. 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에서 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
    * 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있지만 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
    * 메서드 호출 시간이 짧아지므로 효율이 높아진다.

## 4. 오버로딩

### 4.1 오버로딩이란?
* 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩이라고 한다.

### 4.2 오버로딩의 조건
* 메서드 이름이 같아야 한다.
* 매개변수의 개수 또는 타입이 달라야 한다.
* 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
* 즉, 메서드를 호출하였을 때 어떤 메서드가 호출된 것인지 결정할 수 있어야 한다.

### 4.3 오버로딩의 장점
* 같은 기능을 하는 메서드들의 이름을 통일할 수 있다.

### 4.4 가변인자와 오버로딩
* 가변인자는 메서드의 매개변수를 동적으로 지정할 수 있다.
* '타입... 변수명' 형태로 선언한다.
* 가변인자 외에도 매개변수가 있으면 가변인자를 맨 마지막에 배치해야 한다.
```java
String concatenate(String... str) { ... }
System.out.println(concatenate());
System.out.println(concatenate("a"));
System.out.println(concatenate("a", "b"));
System.out.println(concatenate(new String[] {"a", "b"}));
```
* 가변인자는 내부적으로 배열을 이용하는 것이다.
* 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다.
* 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.

